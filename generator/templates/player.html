<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Playing: {{.Title}}">
  <title>{{.Title}} | vsite</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet">
  <!-- daisyUI + Tailwind CSS CDN -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style type="text/tailwindcss">
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    /* Video.js customizations */
    .video-js {
      width: 100%;
      height: auto;
      aspect-ratio: 16/9;
      border-radius: 0.75rem;
      overflow: hidden;
    }

    .vjs-big-play-button {
      background-color: oklch(var(--p) / 0.9) !important;
      border: none !important;
      border-radius: 50% !important;
      width: 80px !important;
      height: 80px !important;
      line-height: 80px !important;
      margin-top: -40px !important;
      margin-left: -40px !important;
    }

    .vjs-big-play-button:hover {
      background-color: oklch(var(--p)) !important;
    }

    .video-js .vjs-control-bar {
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
      height: 4em;
    }

    .video-js .vjs-play-progress,
    .video-js .vjs-volume-level {
      background-color: oklch(var(--p));
    }

    .video-js .vjs-slider:focus {
      box-shadow: 0 0 0 2px oklch(var(--p) / 0.5);
    }
  </style>
</head>

<body class="bg-base-100 text-base-content min-h-screen" data-prev="{{.PrevVideo}}" data-next="{{.NextVideo}}"
  data-back="{{.BackLink}}" data-hasprev="{{.HasPrev}}" data-hasnext="{{.HasNext}}" data-videosrc="{{.VideoSrc}}"
  data-videotype="{{.VideoType}}" data-title="{{.Title}}">
  <div class="container mx-auto px-4 py-8 max-w-6xl">
    <header class="flex flex-wrap items-center gap-4 mb-6 pb-6 border-b border-base-300">
      <a href="{{.BackLink}}" class="btn btn-ghost btn-sm gap-2">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <path d="M19 12H5M12 19l-7-7 7-7" />
        </svg>
        Back
      </a>
      <h1 class="text-xl md:text-2xl font-bold text-base-content flex-1">{{.Title}}</h1>

      <!-- Theme Toggle -->
      <label class="swap swap-rotate">
        <!-- this hidden checkbox controls the state -->
        <input type="checkbox" class="theme-controller" value="light" />
        <!-- sun icon - shows when checked (light mode) -->
        <svg class="swap-on h-8 w-8 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path
            d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" />
        </svg>
        <!-- moon icon - shows when unchecked (dark mode) -->
        <svg class="swap-off h-8 w-8 fill-current" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path
            d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z" />
        </svg>
      </label>
    </header>

    <div class="max-w-5xl mx-auto">
      <div class="rounded-xl overflow-hidden shadow-2xl bg-black">
        <video id="player" class="video-js vjs-big-play-centered" controls preload="auto" autoplay playsinline>
          <source src="{{.VideoSrc}}" type="{{.VideoType}}">
          <p class="vjs-no-js">
            To view this video please enable JavaScript, and consider upgrading to a
            web browser that supports HTML5 video.
          </p>
        </video>
      </div>

      <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mt-6 p-4 bg-base-200 rounded-xl">
        <div class="flex flex-wrap gap-3 items-center justify-center sm:justify-start">
          <a href="{{if .HasPrev}}{{.PrevVideo}}{{else}}#{{end}}"
            class="btn btn-sm btn-ghost gap-2 {{if not .HasPrev}}btn-disabled{{end}}">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <path d="M19 12H5M12 19l-7-7 7-7" />
            </svg>
            Previous
          </a>

          <!-- Chromecast button -->
          <button id="castButton" class="btn btn-sm btn-primary gap-2" title="Cast to Chromecast">
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
              <path
                d="M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" />
            </svg>
            <span id="castButtonText">Cast</span>
          </button>

          <div id="castStatus" class="badge badge-success gap-2 hidden">
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
              <path
                d="M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" />
            </svg>
            <span id="castDeviceName">Casting...</span>
          </div>

          <a href="{{if .HasNext}}{{.NextVideo}}{{else}}#{{end}}"
            class="btn btn-sm btn-ghost gap-2 {{if not .HasNext}}btn-disabled{{end}}">
            Next
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <path d="M5 12h14M12 5l7 7-7 7" />
            </svg>
          </a>
        </div>
        <span class="text-sm text-base-content/60">{{.VideoName}}</span>
      </div>
    </div>
  </div>

  <!-- Toast notification -->
  <div id="toast" class="toast toast-bottom toast-center">
    <div id="toastContent" class="alert alert-info hidden">
      <span id="toastText"></span>
    </div>
  </div>

  <!-- Video.js -->
  <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>

  <script>
    (function () {
      var player;
      var castSession = null;
      var castButton = document.getElementById('castButton');
      var castButtonText = document.getElementById('castButtonText');
      var castStatus = document.getElementById('castStatus');
      var castDeviceName = document.getElementById('castDeviceName');
      var toastContent = document.getElementById('toastContent');
      var toastText = document.getElementById('toastText');
      var castState = 'NOT_CONNECTED';
      var castAvailable = false;

      // Persist theme preference
      (function () {
        const savedTheme = localStorage.getItem('vsite-theme');
        if (savedTheme) {
          document.documentElement.setAttribute('data-theme', savedTheme);
          if (savedTheme === 'light') {
            document.querySelector('.theme-controller').checked = true;
          }
        }

        document.querySelector('.theme-controller').addEventListener('change', function (e) {
          const theme = e.target.checked ? 'light' : 'dark';
          document.documentElement.setAttribute('data-theme', theme);
          localStorage.setItem('vsite-theme', theme);
        });
      })();

      // Show toast message
      function showToast(message, duration) {
        duration = duration || 3000;
        toastText.textContent = message;
        toastContent.classList.remove('hidden');
        setTimeout(function () {
          toastContent.classList.add('hidden');
        }, duration);
      }

      // Check if we're on HTTPS (required for Chromecast)
      function canUseChromecast() {
        return location.protocol === 'https:';
      }

      // Get absolute URL for the video (required for Chromecast)
      function getAbsoluteVideoUrl() {
        var src = document.body.dataset.videosrc;
        if (src.startsWith('http://') || src.startsWith('https://')) {
          return src;
        }
        return new URL(src, window.location.href).href;
      }

      // Initialize Video.js player
      function initPlayer() {
        player = videojs('player', {
          controls: true,
          autoplay: true,
          preload: 'auto',
          fluid: true,
          playbackRates: [0.5, 0.75, 1, 1.25, 1.5, 2],
          controlBar: {
            children: [
              'playToggle',
              'volumePanel',
              'currentTimeDisplay',
              'timeDivider',
              'durationDisplay',
              'progressControl',
              'playbackRateMenuButton',
              'pictureInPictureToggle',
              'fullscreenToggle'
            ]
          }
        });

        // Keyboard navigation
        var body = document.body;
        var hasPrev = body.dataset.hasprev === "true";
        var hasNext = body.dataset.hasnext === "true";
        var prevVideo = body.dataset.prev;
        var nextVideo = body.dataset.next;
        var backLink = body.dataset.back;

        document.addEventListener("keydown", function (e) {
          if (e.target.closest('.video-js')) return;

          if (e.key === "ArrowLeft" && hasPrev) {
            window.location.href = prevVideo;
          } else if (e.key === "ArrowRight" && hasNext) {
            window.location.href = nextVideo;
          } else if (e.key === "Escape") {
            window.location.href = backLink;
          }
        });

        // Auto-next when video ends
        player.on('ended', function () {
          if (hasNext) {
            // Save fullscreen state before navigating
            if (player.isFullscreen()) {
              sessionStorage.setItem('vsite_fullscreen', 'true');
            } else {
              sessionStorage.removeItem('vsite_fullscreen');
            }
            // Save Picture-in-Picture state before navigating
            if (player.isInPictureInPicture()) {
              sessionStorage.setItem('vsite_pip', 'true');
            } else {
              sessionStorage.removeItem('vsite_pip');
            }
            window.location.href = nextVideo;
          }
        });

        // Restore fullscreen state if coming from a previous video
        if (sessionStorage.getItem('vsite_fullscreen') === 'true') {
          sessionStorage.removeItem('vsite_fullscreen');
          // Wait for player to be ready and video to start playing
          player.one('playing', function () {
            player.requestFullscreen();
          });
        }

        // Restore Picture-in-Picture state if coming from a previous video
        if (sessionStorage.getItem('vsite_pip') === 'true') {
          sessionStorage.removeItem('vsite_pip');
          // Wait for player to be ready and video to start playing
          player.one('playing', function () {
            player.requestPictureInPicture();
          });
        }
      }

      // Initialize Chromecast
      function initChromecast() {
        if (!canUseChromecast()) {
          console.log('Chromecast: requires HTTPS');
          return;
        }

        // Show button immediately (always visible on HTTPS)
        castButton.classList.remove('hidden');

        window['__onGCastApiAvailable'] = function (isAvailable) {
          if (isAvailable) {
            initializeCastApi();
          } else {
            castButton.classList.add('btn-disabled');
            castButtonText.textContent = 'Cast unavailable';
          }
        };

        // Load Cast SDK
        var script = document.createElement('script');
        script.src = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';
        script.onerror = function () {
          castButton.classList.add('btn-disabled');
          castButtonText.textContent = 'Cast unavailable';
        };
        document.head.appendChild(script);
      }

      function initializeCastApi() {
        cast.framework.CastContext.getInstance().setOptions({
          receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
          autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
        });

        var context = cast.framework.CastContext.getInstance();

        // Update state when cast state changes
        context.addEventListener(
          cast.framework.CastContextEventType.CAST_STATE_CHANGED,
          function (event) {
            castState = event.castState;

            if (event.castState === cast.framework.CastState.NO_DEVICES_AVAILABLE) {
              castAvailable = false;
              castButtonText.textContent = 'No devices';
            } else if (event.castState === cast.framework.CastState.NOT_CONNECTED) {
              castAvailable = true;
              castButtonText.textContent = 'Cast';
              castButton.classList.remove('btn-disabled');
            } else if (event.castState === cast.framework.CastState.CONNECTING) {
              castButtonText.textContent = 'Connecting...';
            } else if (event.castState === cast.framework.CastState.CONNECTED) {
              var session = context.getCurrentSession();
              if (session) {
                castDeviceName.textContent = 'Casting to ' + session.getCastDevice().friendlyName;
                castStatus.classList.remove('hidden');
                castButton.classList.add('hidden');
              }
            }

            // Show/hide status
            if (event.castState !== cast.framework.CastState.CONNECTED) {
              castStatus.classList.add('hidden');
              castButton.classList.remove('hidden');
            }
          }
        );

        // Cast button click handler
        castButton.addEventListener('click', function () {
          if (castState === cast.framework.CastState.NO_DEVICES_AVAILABLE) {
            showToast('No Chromecast devices found. Make sure your device is on the same network.');
            return;
          }

          if (castState === cast.framework.CastState.CONNECTED) {
            // Disconnect
            var session = context.getCurrentSession();
            if (session) {
              session.endSession(true);
            }
            return;
          }

          context.requestSession().then(
            function () {
              var session = context.getCurrentSession();
              if (session) {
                loadMedia(session);
              }
            },
            function (error) {
              if (error.code === 'cancel') {
                // User cancelled, do nothing
              } else if (error.code === 'no_devices_available') {
                showToast('No Chromecast devices found. Check your network connection.');
              } else {
                showToast('Could not connect to Chromecast: ' + error.description);
              }
            }
          );
        });
      }

      function loadMedia(session) {
        var mediaInfo = new chrome.cast.media.MediaInfo(
          getAbsoluteVideoUrl(),
          document.body.dataset.videotype
        );
        mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
        mediaInfo.metadata.title = document.body.dataset.title;

        var request = new chrome.cast.media.LoadRequest(mediaInfo);
        request.currentTime = player ? player.currentTime() : 0;
        request.autoplay = true;

        session.loadMedia(request).then(
          function () {
            showToast('Playing on ' + session.getCastDevice().friendlyName);
            if (player) {
              player.pause();
            }
          },
          function (error) {
            showToast('Error loading video on Chromecast. Check if the video format is supported.');
            console.log('Error loading media:', error);
          }
        );
      }

      // Initialize everything
      initPlayer();
      initChromecast();
    })();
  </script>
</body>

</html>